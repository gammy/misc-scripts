#!/usr/bin/perl
# A small dict.org query script for console output
#
# Copyright (C) 2005-2013 Kristian Gunstone
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 2 of the License, or
# (at your option) any later version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA.

use strict;
use warnings;

use LWP::UserAgent;
use File::Temp;
use Getopt::Long;

use constant VERSION   => '0.9';
use constant DOCROOT   => 'http://www.dict.org';
use constant USERAGENT => 'dict.org query script v' . VERSION . ' by gammy';

my @headers = ('User-Agent: ' . USERAGENT, 
	       'Referer: '    . DOCROOT);
my @body;

our $ua = LWP::UserAgent->new(agent   => USERAGENT,
	                      timeout => 20);
 
sub show_version {
	print USERAGENT . "\n\n";
}

sub show_help {
	show_version();
	print "Usage: <me> [OPTION]... [QUERY]\n\n";
	print "Example: <me> love\n";
	print "Example: <me> -db gcide love\n\n";
	print "Options:\n";
	print "  -t, -type <type>       Query type. 'help' for list\n";
	print "  -d, -db <database>     Database. 'help' for list\n";
	print "  -h, -help              This text\n";
	print "  -V, -version           Show version\n";
	print "\n";
}

sub trim {
	my $t = shift;
	$t =~ s/^\s+//;
	$t =~ s/\s+$//;
	return $t;
}

sub fmt {
	my $open  = "\e[4m";
	my $close = "\e[0m";

	my $q     = shift;
	my $title = substr trim(shift), 0, -2; 
	my $desc  = trim(shift);

	$desc =~ s/(\Q$q\E)/$open$1$close/gis;

	return("\n" . $open . $title . $close . "\n\n" . $desc . "\n");
}
my $term_height;

if(eval{require Term::Size}){
    (undef, $term_height) = Term::Size::chars(\*STDIN);
}else{
    $term_height = `tput lines` || $ENV{LINES} || 25;
    chomp($term_height);
}

$term_height--;

my %dict = ('db_val'       => [],
	    'db_key'       => [],
	    'strategy_val' => [],
	    'strategy_key' => []);

my ($match, $buf, $dbuf, $output, $found, $tmp);

my %search = ('query' => $ARGV[$#ARGV]);
my ($show_help, $show_version);

my $opts = GetOptions("t|type=s"  => \$search{'strategy'}, 
		      "d|db=s"    => \$search{'database'},
		      "h|help"    => \$show_help,
		      "V|version" => \$show_version);

print "But how can it be anything other than $search{query} ?????????????\n";

if(show_help ==1 ) {
	show_help();
	exit;
}

if($show_version ==1) {
	show_version();
	exit;
}

$| = 1;

print "Connecting...";
my $req = HTTP::Request->new(GET => DOCROOT . "/bin/Dict");
my $res = $ua->request($req);

die "Request for '@_' failed with " . $res->status_line . "\n" unless $res->is_success;
print "ok.\n";
$buf = $res->content;

$tmp = $1 if $buf=~m/<select name=\"Strategy\">(.*?)<\/select>/si;
while($tmp =~ m/value="(.+?)".*?>(.+?)\n/sig){
    push(@{$dict{strategy_val}}, trim($1));
    push(@{$dict{strategy_key}}, trim($2));
}
$tmp = $1 if $buf=~m/<select name=\"Database\">(.*?)<\/select>/si;
while($tmp =~ m/value="(.+?)".*?>(.+?)\n/sig){
    push(@{$dict{db_val}}, trim($1));
    push(@{$dict{db_key}}, trim($2));
}

$tmp = "";

$search{'strategy'} = $dict{strategy_val}[0] if ! defined $search{'strategy'}; 
$search{'database'} = $dict{db_val}[0] if ! defined $search{'database'};

$found = 0;
for (@{$dict{db_val}}){
    if($search{'database'} eq $_){
	    $found = 1;
	    last;
    }
}
if($found == 0){
    print "Valid database strings:\n";
    for (0 .. @{$dict{db_val}}-1) {
	    my ($k, $v) = ($dict{db_key}[$_],
			   $dict{db_val}[$_]);
	    printf("%s%s-\t%s\n", $v, " "x(12-length($v)), $k);
    }
    exit;
}
    
$found = 0;
for (@{$dict{strategy_val}}){
    if($search{'strategy'} eq $_){
	    $found = 1;
	    last;
    }
}

if($found == 0){
    print "Valid search type strings:\n";
    for (0 .. @{$dict{strategy_val}}-1) {
	    my ($k, $v) = ($dict{strategy_key}[$_],
			   $dict{strategy_val}[$_]);
	    printf("%s%s-\t%s\n", $v, " "x(12-length($v)), $k);
    }
    exit;
}

print "Getting match of \"$search{'query'}\"...";

$req = HTTP::Request->new(POST => DOCROOT . "/bin/Dict");
$req->content_type('application/x-www-form-urlencoded');
$req->content("Form=Dict1" . "&" .
	      "Query=$search{'query'}" . "&" .
	      "Strategy=$search{'strategy'}" . "&" . 
	      "Database=$search{'database'}");
$res = $ua->request($req);
die "Request for '@_' failed with $res->status_line\n" unless $res->is_success;
$buf = $res->content;

print "ok\n\n";

$buf =~s/\(<a.*?href="(.+?)>(.+?)<\/a>\)/($2)/gis; # Broken html...
$dbuf = $buf;
$dbuf =~s/<a.*?href=\".*?\".*?>(.+?)<\/a>/$1/gis;
$dbuf =~s/<pre><\/pre>//gs;
$buf =~s/\n//gs;
$buf =~s/<a.*?href=\".*?\".*?>(.+?)<\/a>/$1/gis;
$buf =~s/<.*?>//gs;

$_ = $buf;

if(/([0-9]+ definitions? found) for/si){
	$match = $1;
	$dbuf =~s/<html>.*?found//gis;
	$output .= fmt($search{query}, $1, $2) 
		while $dbuf =~ m/<b>(.+?):?<\/b><pre>(.+?)<\/pre>/gis;
}elsif(/(No definitions? found) for/si){
	$match = $1;
	$match = "$1$2" if /(No definitions? found) for ".+?"(, perhaps you mean:)/si;
	$dbuf =~s/<html>.*?found//gis;
	$output .= fmt($search{query}, $1, $2) 
		while $dbuf =~ m/<b>(.+?:)<\/b>(.+?)</gis;
}else{
	$dbuf =~s/<html>.*?<\/form>//gis;
	$output .= fmt($search{query}, $1, $2) 
		while $dbuf =~ m/<b>(.+?:)<\/b>(.+?)</gis;
}

$dbuf = $buf = '';
$output = "$match\n$output" if "$match" ne "";

if(($output =~tr/\n//) > $term_height){
	my $tmp = File::Temp->new(TEMPLATE => ".dictorg-" . $search{'query'} . "-XXXX", 
                                       DIR => $ENV{HOME});
	open(FILE, '>' . $tmp->filename) or die "Could not open \"$tmp->filename\"";
	print FILE $output;
	close(FILE);
	system('less', '-r', $tmp->filename);
}else{
    print $output;
}
