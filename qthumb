#!/bin/bash
# A quick and dirty multitool which uses 'convert' to do the job. 
# By gammy.
#
# In essence it just runs 'convert' on each image in the source path. 
#
# You can  pass any arguments along to 'convert' itself, allowing you to use 
# this as a multi-file wrapper around it.

src=""
dst="thumbs"

prefix="thumb_"
postfix=""

convert="convert"

usage() {
	echo -e "Quick n dirty '$convert' multitool\n"
	echo "Usage: $(basename $0) -s <source path> [options] -- <convert args>"
	echo -e "Example: $(basename $0) -p thumb_ -s /originals/ -d ./thumbs/ -- -size 100x100\n"
	echo "-s <src>      set source path       (default: \"$src\")"
	echo "-d <dst>      set destination path  (default: \"$dst\")"
	echo "-p <prefix>   set target prefix     (default: \"$prefix\")"
	echo -e "-P <postfix>  set target postfix    (default: \"$postfix\")\n"
	echo "Only the -s argument is required to run."
}

while [ $# -gt 0 ]; do 
	case "$1" in
		--) shift; break;;
		-s) src="$2";;
		-d) dst="$2";;
		-p) prefix="$2";;
		-P) postfix="$2";;
		-h) usage
		    exit 1;;
	esac
	shift
done

if [ -z ${src} ] || [ $# = 0 ]; then
	usage
	exit 1
fi

if [ $(which "${convert}" | wc -l)  = 0 ]; then
	echo "Can't find command \"${convert}\""
	exit 0
fi

if [ ! -d ${dst} ]; then
	mkdir -v ${dst}
fi

find ${src} -maxdepth 1 -type f | while read old; do

	if [ $(file "${old}" | grep image | wc -l) != 1 ]; then
		continue 
	fi

	type=${old##*.}

	bn=$(basename "${old}" ".${type}")
	new="${dst}/${prefix}${bn}${postfix}.${type}"

	if [ -e "${new}" ]; then 
		echo "Already exists: \"${new}\""
		continue
	fi

		
	echo $convert \"${old}\" $@ \"${new}\"
	$convert "${old}" $@ "${new}" || echo "^ ERROR"
done
