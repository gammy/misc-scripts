#!/usr/bin/env python3
# playrand: Run an arbitrary command on any files matching a mime-type which are
#           found somewhere in the specified directory tree.
#
# The simplest example: `playrand --mime-type '' -- ls -l`
# See `playrand --help` for a full list of features.
#
# Some abilities:
# - Interactive mode, which prompts for user input before and after each file:
#   'q' quits, 'r' re-runs, 'd' prompts for deletion and any other key
#    continues execution (--prompt)
# - Store the list of scanned files to disk (--use-cache, --rebuild-cache)
# - Shuffle the list
# - Only add files matching a particular string (--contains)
# - Loop through the list forever

import argparse
import os
import glob
import random
import subprocess
import magic    # pip install libmagic filemagic
import readchar # pip install readchar

def list_add(filename):
	print("Add {:s}".format(filename))
	file_list.append(filename)

def cache_add(filename):
	list_add(filename)
	with open(cache_file, 'ab') as file_out:
		file_out.write(filename.encode())
		file_out.write("\n".encode())

def scan_files(args, handler):
	for root, dirs, files in os.walk(args.path):
		for f in files:
			filename = os.path.join(root, f)
			if args.contains and not args.contains in filename:
				continue
			with magic.Magic(flags=magic.MAGIC_MIME_TYPE) as m:
				mime_type = m.id_filename(filename)
				if mime_type.startswith(args.mime_type):
					handler(filename)

def run_file(args, f):
	call = args.callee + [f]
	#print(call)
	#print()

	subprocess.call(call)

	if not args.prompt:
		return True

	print("< " + f)
	print("[q]uit, [d]elete, [r]erun "
	      "or any other key to continue")
	key = readchar.readkey()
	if key == 'q':
		return False
	if key == 'r':
		run_file(args, f)
	if key == 'd':
		print("Are you sure? [y] confirms, any other cancels")
		key = readchar.readkey()
		if key == 'y':
			os.unlink(f)
	return True

def run_files(args, file_list):
	for f in file_list:
		if args.prompt:
			print("> " + f)
			print("[s]kip, [q]uit or any other key to proceed")
			key = readchar.readkey()
			if key == 'q':
				return False
			if key == 's':
				continue
		
		if run_file(args, f) == False:
			return False
	return True


parser = argparse.ArgumentParser()

parser.add_argument("-p", "--path", 
		    type = str,
		    default = '.',
		    help = "Directory path to work with")
parser.add_argument("-t", "--mime-type", 
		    type = str,
		    default = 'video',
		    help = "Mime type to look for. Parsed by 'startswith'")
parser.add_argument("-C", "--contains", 
		    type = str,
		    default = '',
		    help = "Full filename must contain <this>. "
		           "Parsed by 'in'")
parser.add_argument("-s", "--shuffle", 
		    default = False,
		    action = 'store_true',
		    help = "Shuffle the list")
parser.add_argument("-c", "--rebuild-cache", 
		    default = False,
		    action = 'store_true',
		    help = "Generate a new cache file, which is used when "
		           "invoked with --use-cache")
parser.add_argument("-u", "--use-cache", 
		    default = False,
		    action = 'store_true',
		    help = "Use the cache rather than the file system")
parser.add_argument("-P", "--cache-profile", 
		    default = "default",
		    help = "When used with --use-cache, "
		           "specify which cache profile (file) to use")
parser.add_argument("-i", "--prompt", 
		    default = False,
		    action = 'store_true',
		    help = "Basic prompt mode; Ask y/n before each entry"
		           ", and stop with a prompt after each entry")
parser.add_argument("-l", "--loop", 
		    default = False,
		    action = 'store_true',
		    help = "Loop once entries are exhausted")
parser.add_argument("callee",
		    nargs = "+",
		    help = "Command and args to call")

args = parser.parse_args()

cache_file = args.path + '/' + '.playrand-' + args.cache_profile + '.cache'

file_list = []
cwd = os.getcwd()

if args.rebuild_cache:
	args.use_cache = True

if args.use_cache:
	if not os.path.isfile(cache_file):
		args.rebuild_cache = True

	if args.rebuild_cache:
		print("Building cache: " + cache_file)
		print("Please wait. This may be very slow on a network!")
		# Remove old cache
		tmp = open(cache_file, 'w');
		tmp.close()
		scan_files(args, cache_add)
	else:
		print("Using cache: " + cache_file)
		with open(cache_file, "rb") as file_in:
			for f in file_in:
				file_list.append(f.decode().rstrip())
else:
	scan_files(args, list_add)

if args.shuffle:
	random.shuffle(file_list)

file_count = len(file_list)
print("{:d} files".format(file_count))

if file_count == 0:
	exit

if args.loop:
	busy = True
	while busy:
		busy = run_files(args, file_list)
else:
	run_files(args, file_list)
